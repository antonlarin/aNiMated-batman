#include "solverwrapper.hpp"
using namespace v8;


Persistent<Function> Solver::constructor;

Solver::Solver() {
	mTask = HES_CreateTask(&mStat);
	if (Solver::StatExp(mStat))
		return;

	mGridN = -1;
	mGridM = -1;
	mIsSolved = false;
	InitializeDefault();
}

Solver::~Solver() {
	if (mTask != NULL) {
		HES_FreeTask(mTask, &mStat);
		Solver::StatExp(mStat);
	}
}


void Solver::InitializeDefault() {
	const double timeLimit = SW_DEFAULT_TIME;
	const int32_t dim      = SW_DEFAULT_GRID;
	const char* zeroF      = SW_DEFAULT_FUNC;

	// Set default task parameters
	HES_SetTimeLimit          (mTask, timeLimit, &mStat); if (StatExp(mStat)) return;
	HES_SetDimensions         (mTask, dim, dim,  &mStat); if (StatExp(mStat)) return;
	HES_SetInitialConditions  (mTask, zeroF,     &mStat); if (StatExp(mStat)) return;
	HES_LeftBoundaryCondition (mTask, zeroF,     &mStat); if (StatExp(mStat)) return;
	HES_RightBoundaryCondition(mTask, zeroF,     &mStat); if (StatExp(mStat)) return;
	HES_SetRHSFunction        (mTask, zeroF,     &mStat); if (StatExp(mStat)) return;

	mGridN = dim;
	mGridM = dim;
}



void Solver::Exp(const char* message) {
	Isolate* isolate = Isolate::GetCurrent();
	isolate->ThrowException(Exception::Error(
		String::NewFromUtf8(isolate, message)));
}

bool Solver::StatExp(const HES_Status& status) {
	if (status.ErrCode != HES_ERRNO_NONE) {
		Solver::Exp(status.Message);
		return true;
	}
	return false;
}



void Solver::Init(Handle<Object> exports) {
	Isolate* isolate = Isolate::GetCurrent();

	// Prepare constructor template
	Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
	tpl->SetClassName(String::NewFromUtf8(isolate, "Solver"));
	tpl->InstanceTemplate()->SetInternalFieldCount(5);

	// Prototype
	NODE_SET_PROTOTYPE_METHOD(tpl, "setTimeLimit",           SetTimeLimit);
	NODE_SET_PROTOTYPE_METHOD(tpl, "setDimensions",          SetDimensions);
	NODE_SET_PROTOTYPE_METHOD(tpl, "setInitialConditions",   SetInitialConditions);
	NODE_SET_PROTOTYPE_METHOD(tpl, "leftBoundaryCondition",  LeftBoundaryCondition);
	NODE_SET_PROTOTYPE_METHOD(tpl, "rightBoundaryCondition", RightBoundaryCondition);
	NODE_SET_PROTOTYPE_METHOD(tpl, "setRHSFunction",         SetRHSFunction);
	NODE_SET_PROTOTYPE_METHOD(tpl, "getLayer",               GetLayer);
	NODE_SET_PROTOTYPE_METHOD(tpl, "getTable",               GetTable);
	NODE_SET_PROTOTYPE_METHOD(tpl, "getMaxTableValue",       GetMaxTableValue);
	NODE_SET_PROTOTYPE_METHOD(tpl, "getMinTableValue",       GetMinTableValue);
	NODE_SET_PROTOTYPE_METHOD(tpl, "getErrorNorm",           GetErrorNorm);
	NODE_SET_PROTOTYPE_METHOD(tpl, "solve",                  Solve);

	constructor.Reset(isolate, tpl->GetFunction());
	exports->Set(String::NewFromUtf8(isolate, "Solver"),
		tpl->GetFunction());
}



void Solver::New(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.IsConstructCall()) {
		// Invoked as constructor: `new Solver(...)`
		Solver* obj = new Solver();
		obj->Wrap(args.This());
		args.GetReturnValue().Set(args.This());
	} else {
		// Invoked as plain function `Solver(...)`, turn into construct call.
		// TODO
	}
}



void Solver::SetTimeLimit(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	if (!args[0]->IsNumber()) {
		Solver::Exp("Argument must be a number");
		return;
	}

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	double limit = args[0]->NumberValue();
	HES_SetTimeLimit(obj->mTask, limit, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = false;
}



void Solver::SetDimensions(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 2) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	if (!args[0]->IsInt32() || !args[1]->IsInt32()) {
		Solver::Exp("Argument must be an integers");
		return;
	}

	int32_t n = args[0]->Int32Value();
	int32_t m = args[1]->Int32Value();
	if (n <= 0 || m <= 0) {
		Solver::Exp("Grid dimensions must greater then zero");
		return;
	}

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_SetDimensions(obj->mTask, n, m, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mGridN = n;
	obj->mGridM = m;
}



void Solver::SetInitialConditions(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	String::Utf8Value asciiFStr(args[0]->ToString());
	const char* cFStr = *asciiFStr;

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_SetInitialConditions(obj->mTask, cFStr, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = false;
}



void Solver::LeftBoundaryCondition(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	String::Utf8Value asciiFStr(args[0]->ToString());
	const char* cFStr = *asciiFStr;

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_LeftBoundaryCondition(obj->mTask, cFStr, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = false;
}



void Solver::RightBoundaryCondition(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	String::Utf8Value asciiFStr(args[0]->ToString());
	const char* cFStr = *asciiFStr;

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_RightBoundaryCondition(obj->mTask, cFStr, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = false;
}



void Solver::SetRHSFunction(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	String::Utf8Value asciiFStr(args[0]->ToString());
	const char* cFStr = *asciiFStr;

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_SetRHSFunction(obj->mTask, cFStr, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = false;
}



void Solver::GetLayer(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	if (!args[0]->IsInt32()) {
		Solver::Exp("Argument must be an integer");
		return;
	}

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	if (!obj->mIsSolved) {
		Solver::Exp("Task must be solved before getting result");
		return;
	}

	int32_t mGridN = obj->mGridN;
	int32_t mGridM = obj->mGridM;

	int32_t index = args[0]->Int32Value();
	if (index < 0 || index > mGridM) {
		Solver::Exp("Index out of range");
		return;
	}

	double* layer = new double[mGridN + 1];
	HES_GetLayer(obj->mTask, index, layer, &obj->mStat);
	if (StatExp(obj->mStat)) {
		delete[] layer;
		return;
	}

	// Convert native layer array to V8 array
	Local<Array> output = Array::New(isolate, mGridN + 1);
	for (int i = 0; i <= mGridN; i++) {
		auto oi = Number::New(isolate, layer[i]);
		output->Set(i, oi);
	}

	delete[] layer;
	args.GetReturnValue().Set(output);
}



void Solver::GetTable(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	if (!obj->mIsSolved) {
		Solver::Exp("Task must be solved before getting result");
		return;
	}

	int32_t mGridN = obj->mGridN + 1;
	int32_t mGridM = obj->mGridM + 1;

	double* table = new double[mGridN * mGridM];
	HES_GetTable(obj->mTask, table, &obj->mStat);
	if (StatExp(obj->mStat)) {
		delete[] table;
		return;
	}

	// Convert table to V8 'matrix' (array of arrays)
	Local<Array> rows = Array::New(isolate, mGridM);
	for (int i = 0; i < mGridM; i++) {
		Local<Array> row = Array::New(isolate, mGridN);
		rows->Set(i, row);
		for (int j = 0; j < mGridN; j++) {
			double tij = table[mGridN * i + j];
			auto rowj = Number::New(isolate, tij);
			row->Set(j, rowj);
		}
	}

	delete[] table;
	args.GetReturnValue().Set(rows);
}



void Solver::GetMaxTableValue(const Arguments& args)
{
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	if (!obj->mIsSolved) {
		Solver::Exp("Task must be solved before getting result");
		return;
	}

	double maxTableValue = HES_GetMaxFormTable(obj->mTask, &obj->mStat);
	if (StatExp(obj->mStat)) {
		return;
	}

	Local<Number> output = Number::New(isolate, maxTableValue);
	args.GetReturnValue().Set(output);
}



void Solver::GetMinTableValue(const Arguments& args)
{
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	if (!obj->mIsSolved) {
		Solver::Exp("Task must be solved before getting result");
		return;
	}

	double minTableValue = HES_GetMinFormTable(obj->mTask, &obj->mStat);
	if (StatExp(obj->mStat)) {
		return;
	}

	Local<Number> output = Number::New(isolate, minTableValue);
	args.GetReturnValue().Set(output);
}



void Solver::GetErrorNorm(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	if (args.Length() < 1) {
		Solver::Exp("Invalid passed arguments count");
		return;
	}

	String::Utf8Value asciiFStr(args[0]->ToString());
	const char* cFStr = *asciiFStr;

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	double errorNorm = HES_GetErrorNorm(obj->mTask, cFStr, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	Local<Number> output = Number::New(isolate, errorNorm);
	args.GetReturnValue().Set(output);
}



void Solver::Solve(const Arguments& args) {
	Isolate* isolate = Isolate::GetCurrent();
	HandleScope scope(isolate);

	Solver* obj = ObjectWrap::Unwrap<Solver>(args.Holder());
	HES_Solve(obj->mTask, &obj->mStat);
	if (StatExp(obj->mStat))
		return;

	obj->mIsSolved = true;
}